{"mappings":"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","sources":["main.js","000_JS_code/m_sketch_v1.js"],"sourcesContent":["// import './libraries/p5.js';\nimport p5 from 'p5';\nimport { setup, draw, windowResized, drawGrid, findClosestDotToMouse, mouseMoved, initializeGrid, createDotPositions, createOrUpdateLine, drawLinesArray, ConnectorLine} from './000_JS_code/m_sketch_v1.js';\n\nnew p5((p) => {\n  p.setup = () => {\n    setup(p);\n  };\n\n  p.draw = () => {\n    draw(p);\n  };\n  p.drawGrid = () => {\n    drawGrid(p);\n  };\n\n  p.windowResized = () => {\n    windowResized(p);\n  };\n  p.initializeGrid = () => {\n    initializeGrid(p);\n  };\n\n\n  p.mouseMoved = () => {\n    mouseMoved(p);\n  };\n  p.createDotPositions = () => {\n    createDotPositions(p);\n  };\n  p.findClosestDotToMouse = () => {\n    findClosestDotToMouse(p);\n  };\n  p.createOrUpdateLine = () => {\n    createOrUpdateLine(p);\n  };\n  p.drawLinesArray = () => {\n    drawLinesArray(p);\n  };\n});\n\n\nimport './000_JS_code/m_sketch_v1.js';\n\n\n","import p5 from 'p5';\n\nlet dotGrid = []; // Array to store dot positions and colors\nlet closestIndex = -1; // Store the index of the closest dot to the mouse\nlet closestDotIndexOnLoad;\nlet lines = [];\nlet singleLineDotIndices = [];\n\nlet colRowAmt = 12;\nlet defaultEllipseColor = 150;\nlet ellipseSize = 4;\n\nlet maxAmountOfLines = 10;\n\nlet lineSettings = {\n    inside: 3,\n    outside: 20,\n    colors: [\n        { name: \"red\", value: [255, 0, 0] },\n        { name: \"green\", value: [0, 255, 0] },\n        { name: \"blue\", value: [0, 0, 255] },\n    ],\n    getRandomColor: function () {\n        let randomIndex = Math.floor(Math.random() * this.colors.length);\n        return this.colors[randomIndex].value;\n    },\n};\n\nlet colorSelected;\nlet bgColor = 249;\n\n// let p; // p5 instance\nlet divWidth;\nlet timing = 500;\n\nexport function setup(p) {\n    let canvasDiv = p.select('#p5_canvas');\n\n\n    let divWidth = canvasDiv.width;\n\n    let canvas = p.createCanvas(divWidth, divWidth);\n    canvas.parent(\"p5_canvas\");\n    initializeGrid(p); // Initialize the grid positions\n    p.noLoop(); // Only draw when necessary\n\n\n    // setInterval(() => {\n    //     handleMouseMovement(p);\n    // }, timing); // Call handleMouseMovement every 5 seconds\n\n}\n\nexport function draw(p) {\n    p.blendMode(p.BLEND); // Reset blend mode to default\n    p.background(bgColor); // Clear the background\n\n    p.blendMode(p.DIFFERENCE); // Set blend mode to multiply\n    drawLinesArray(p); // Draw the line between the dots\n    \n    p.blendMode(p.BLEND); // Reset blend mode to default\n    drawGrid(p); // Draw the grid of dots\n}\n\nexport function createDotPositions(p) {\n    // Get the start and end dots\n    let dotPosition1 = singleLineDotIndices[0];\n    \n\n    let dotPosition2;\n    let dotPosition3;\n\n    if (singleLineDotIndices.length <= 1) {\n        dotPosition2 = dotPosition1;\n        dotPosition3 = dotPosition1;\n    } else if (singleLineDotIndices.length <= 2) {\n        dotPosition2 = singleLineDotIndices[singleLineDotIndices.length - 1];\n        dotPosition3 = singleLineDotIndices[singleLineDotIndices.length - 1];\n    } else {\n        dotPosition2 = singleLineDotIndices[singleLineDotIndices.length - 2];\n        dotPosition3 = singleLineDotIndices[singleLineDotIndices.length - 1];\n    }\n    // Create or update a line based on the positions of dotPosition1 and dotPosition2\n    createOrUpdateLine(p, dotPosition1, dotPosition2, dotPosition3);\n}\n\nexport function createOrUpdateLine(p, dotPosition1, dotPosition2, dotPosition3) {\n\n    // Check if dotPosition1 and dotPosition2 are on the same vertical or horizontal plane\n    if (dotPosition1.x === dotPosition3.x || dotPosition1.y === dotPosition3.y) {\n        // If there are no lines or the last line is not a lineStraight(or is a lineCurve), create a new lineStraight\n        if (\n            lines.length === 0 ||\n            !(lines[lines.length - 1] instanceof ConnectorLine)\n        ) {\n            // startNewLine = true;\n            let newLine = new ConnectorLine(\n                p,\n                dotPosition1,\n                dotPosition3,\n                colorSelected,\n                lineSettings.inside,\n                lineSettings.outside\n            );\n\n            if (lines.length >= maxAmountOfLines) {\n                lines.shift(); // Remove the first line\n            }\n            lines.push(newLine);\n        } else {\n            let newLine = new ConnectorLine(\n                p,\n                dotPosition1,\n                dotPosition3,\n                colorSelected,\n                lineSettings.inside,\n                lineSettings.outside\n            );\n            lines[lines.length - 1] = newLine;\n        }\n    } else {\n        startNewLine = true;\n\n        // Create a new line and add it to the array\n        let newLine = new ConnectorLine(\n            p,\n            dotPosition2,\n            dotPosition3,\n            lineSettings.getRandomColor(),\n            lineSettings.inside,\n            lineSettings.outside\n        );\n        if (lines.length >= maxAmountOfLines) {\n            lines.shift(); // Remove the first line\n        }\n\n        lines.push(newLine);\n    }\n}\n\nexport function drawLinesArray(p) {\n\n    // Draw all the lines in the array\n    for (let line of lines) {\n        line.drawLine();\n    }\n\n}\n\nlet lastClosestIndex = -1;\n\nexport function findClosestDotToMouse(p) {\n    let closestDist = Infinity;\n    let closestIndex = -1;\n\n    for (let i = 0; i < dotGrid.length; i++) {\n        let dot = dotGrid[i];\n        let d = p.dist(p.mouseX, p.mouseY, dot.x, dot.y);\n        if (d < closestDist) {\n            closestDist = d;\n            closestIndex = i;\n        }\n    }\n\n    // If the closest dot has changed, add it to the singleLineDotIndices\n    if (closestIndex !== lastClosestIndex) {\n        singleLineDotIndices.push(dotGrid[closestIndex]);\n        lastClosestIndex = closestIndex;\n    }\n\n    return closestIndex;\n}\n\nlet startNewLine = false;\nlet mouseHasMoved = false;\nexport function mouseMoved(p) {\n\n    // If the mouse has not moved before, find the closest dot\n    if (!mouseHasMoved || startNewLine) {\n        let startingIndex = findClosestDotToMouse(p);\n        singleLineDotIndices[0] = dotGrid[startingIndex];\n        colorSelected = lineSettings.getRandomColor();\n        mouseHasMoved = true;\n        startNewLine = false;\n    }\n    createDotPositions(p);\n    findClosestDotToMouse(p);\n    p.redraw(); // Redraw the canvas with the new line\n}\n\n// export function handleMouseMovement(p) {\n//     console.log('handleMouseMovement',p);\n//     // If the mouse has not moved before, find the closest dot\n//     if (!mouseHasMoved || startNewLine) {\n//         let startingIndex = findClosestDotToMouse(p);\n//         singleLineDotIndices[0] = dotGrid[startingIndex];\n//         colorSelected = lineSettings.getRandomColor();\n//         mouseHasMoved = true;\n//         startNewLine = false;\n//     }\n//     createDotPositions(p);\n//     findClosestDotToMouse(p);\n//     p.redraw(); // Redraw the canvas with the new line\n// }\n\nexport function windowResized(p) {\n    let canvasDiv = p.select('#p5_canvas');\n    let divWidth = canvasDiv.width;\n\n    p.resizeCanvas(divWidth, divWidth);\n    initializeGrid(p); // Reinitialize the grid for the new size\n    createDotPositions(p);\n    p.redraw(); // Redraw since we are not looping\n}\n\nexport function initializeGrid(p) {\n\n    dotGrid = []; // Clear the previous grid\n    let spacingX = p.width / colRowAmt;\n    let spacingY = 160;\n\n    for (let i = 0; i < colRowAmt; i++) {\n        for (let j = 0; j < colRowAmt; j++) {\n            let x = i * spacingX + spacingX / 2;\n            let y = j * spacingY + spacingY;\n            dotGrid.push({ x: x, y: y, color: defaultEllipseColor });\n        }\n    }\n}\n\nexport function drawGrid(p) {\n    for (let i = 0; i < dotGrid.length; i++) {\n        let dot = dotGrid[i];\n        p.fill(dot.color); // Set the fill color for each dot\n        p.noStroke(); // No outline for the dots\n        p.ellipse(dot.x, dot.y, ellipseSize, ellipseSize); // Draw each dot\n    }\n}\n\n\nexport class ConnectorLine {\n    constructor(p, startDot, endDot, color, lineInside, lineOutside) {\n        this.p = p;\n        this.startDot = startDot;\n        this.endDot = endDot;\n        this.color = color;\n        this.lineInside = lineInside;\n        this.lineOutside = lineOutside;\n        this.d = lineInside;\n        this.calculateSlopes = this.calculateSlopes.bind(this);\n        this.calculateVertexes = this.calculateVertexes.bind(this);\n \n    };\n    \n\n\n    calculateSlopes() {\n\n\n        let angle = this.p.atan2 (\n            this.endDot.y - this.startDot.y,\n            this.endDot.x - this.startDot.x\n        );\n        let slope, perpSlope;\n        if (angle === this.p.PI / 2 || angle === -this.p.PI / 2) {\n            slope = Infinity; // or NaN, depending on your use case\n            perpSlope = 0;\n        } else {\n            slope = this.p.tan(angle);\n            perpSlope = -1 / slope;\n        }\n        return { perpSlope, angle };\n    }\n\n    calculateVertexes() {\n        let { perpSlope, angle } =this.calculateSlopes();\n\n        let dMultiplier = 1 + 1 / 3;\n        let deltaX = this.d * dMultiplier * this.p.cos(angle);\n        let deltaY = this.d * dMultiplier * this.p.sin(angle);\n\n        let endAnchor1X,\n            endAnchor1Y,\n            endAnchor2X,\n            endAnchor2Y,\n            startAnchor1X,\n            startAnchor1Y,\n            startAnchor2X,\n            startAnchor2Y;\n\n        if (perpSlope === 0) {\n            // original line is vertical\n            endAnchor1X = this.endDot.x + this.d;\n            endAnchor1Y = this.endDot.y;\n            endAnchor2X = this.endDot.x - this.d;\n            endAnchor2Y = this.endDot.y;\n\n            startAnchor1X = this.startDot.x - this.d;\n            startAnchor1Y = this.startDot.y;\n            startAnchor2X = this.startDot.x + this.d;\n            startAnchor2Y = this.startDot.y;\n        } else if (this.startDot.y === this.endDot.y) {\n            // original line is horizontal\n            endAnchor1X = this.endDot.x;\n            endAnchor1Y = this.endDot.y + this.d;\n            endAnchor2X = this.endDot.x;\n            endAnchor2Y = this.endDot.y - this.d;\n\n            startAnchor1X = this.startDot.x;\n            startAnchor1Y = this.startDot.y - this.d;\n            startAnchor2X = this.startDot.x;\n            startAnchor2Y = this.startDot.y + this.d;\n        } else {\n            // original line is not vertical or horizontal\n            // this is what is getting called instead of the stuff below when moving right to left\n            endAnchor1X =\n                this.endDot.x + this.d / Math.sqrt(1 + perpSlope * perpSlope);\n            endAnchor1Y = this.endDot.y + perpSlope * (endAnchor1X - this.endDot.x);\n            endAnchor2X = this.endDot.x - this.d / Math.sqrt(1 + perpSlope * perpSlope);\n            endAnchor2Y = this.endDot.y + perpSlope * (endAnchor2X - this.endDot.x); // Use endAnchor2X here\n\n            startAnchor1X =\n                this.startDot.x - this.d / Math.sqrt(1 + perpSlope * perpSlope);\n            startAnchor1Y =\n                this.startDot.y + perpSlope * (startAnchor1X - this.startDot.x);\n            startAnchor2X =\n                this.startDot.x + this.d / Math.sqrt(1 + perpSlope * perpSlope);\n            startAnchor2Y =\n                this.startDot.y + perpSlope * (startAnchor2X - this.startDot.x); // Use startAnchor2X here\n        }\n\n        let endControl1X = endAnchor1X + deltaX;\n        let endControl1Y = endAnchor1Y + deltaY;\n        let endControl2X = endAnchor2X + deltaX;\n        let endControl2Y = endAnchor2Y + deltaY;\n\n        let startControl1X = startAnchor1X - deltaX;\n        let startControl1Y = startAnchor1Y - deltaY;\n        let startControl2X = startAnchor2X - deltaX;\n        let startControl2Y = startAnchor2Y - deltaY;\n\n        return {\n            startControl2Y,\n            startControl2X,\n            startAnchor2Y,\n            startAnchor2X,\n            startControl1X,\n            startControl1Y,\n            startAnchor1X,\n            startAnchor1Y,\n            endAnchor1X,\n            endAnchor1Y,\n            endControl1X,\n            endControl1Y,\n            endAnchor2X,\n            endAnchor2Y,\n            endControl2X,\n            endControl2Y,\n        };\n    }\n\n    drawLine() {\n        let {\n            startControl2Y,\n            startControl2X,\n            startAnchor2Y,\n            startAnchor2X,\n            startControl1X,\n            startControl1Y,\n            startAnchor1X,\n            startAnchor1Y,\n            endAnchor1X,\n            endAnchor1Y,\n            endControl1X,\n            endControl1Y,\n            endAnchor2X,\n            endAnchor2Y,\n            endControl2X,\n            endControl2Y,\n        } = this.calculateVertexes();\n\n        // Draw the line\n        this.p.noStroke();\n        this.p.strokeWeight(this.lineOutside);\n        this.p.fill(...this.color);\n        this.p.beginShape();\n        this.p.vertex(endAnchor1X, endAnchor1Y);\n        this.p.bezierVertex(\n            endControl1X,\n            endControl1Y,\n            endControl2X,\n            endControl2Y,\n            endAnchor2X,\n            endAnchor2Y\n        );\n        this.p.vertex(startAnchor1X, startAnchor1Y);\n        this.p.bezierVertex(\n            startControl1X,\n            startControl1Y,\n            startControl2X,\n            startControl2Y,\n            startAnchor2X,\n            startAnchor2Y\n        );\n        this.p.endShape(this.p.CLOSE);\n    }\n}\n"],"names":[],"version":3,"file":"main.js.map"}